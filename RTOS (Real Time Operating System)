// RTOS Framework for Project 1
// Fall 2014
// Jason Losh

//-----------------------------------------------------------------------------
// Objectives and notes             
//-----------------------------------------------------------------------------

// Target uC:       33FJ128MC802
// Devices used:    LEDs and PBs

// Hardware description:
// Red LED
//   anode connected through 100ohm resistor to RB5 (pin 14), cathode grounded
// Green LED
//   anode connected through 100ohm resistor to RB4 (pin 11), cathode grounded
// Yellow LED
//   anode connected through 100ohm resistor to RB3 (pin 7), cathode grounded
// Orange LED
//   anode connected through 100ohm resistor to RB2 (pin 6), cathode grounded
// Push Buttons
//   push button 0 connected between RB12 (pin 23) and ground
//   push button 1 connected between RB13 (pin 24) and ground
//   push button 2 connected between RB14 (pin 25) and ground
//   push button 3 connected between RB15 (pin 26) and ground

//-----------------------------------------------------------------------------
// Device includes and assembler directives             
//-----------------------------------------------------------------------------

#include <p33FJ128MC802.h>
#include <stdio.h>
#define FCY 40000000UL                       // instruction cycle rate
#include <libpic30.h>                        // __delay32
                                             // __delay_ms (max value is 268)
                                             // __delay_us

#define PIN_YELLOW LATBbits.LATB3            // define i/o... change as needed
#define PIN_ORANGE LATBbits.LATB2
#define PIN_GREEN LATBbits.LATB4
#define PIN_RED LATBbits.LATB5
#define PIN_PB0 PORTBbits.RB12
#define PIN_PB1 PORTBbits.RB13
#define PIN_PB2 PORTBbits.RB14
#define PIN_PB3 PORTBbits.RB15

//-----------------------------------------------------------------------------
// RTOS Defines and Kernel Variables                
//-----------------------------------------------------------------------------

// function pointer
typedef void (*_fn)();

#define TRUE  1
#define FALSE 0

// semaphore
#define MAX_QUEUE_SIZE 10
struct semaphore
{
  unsigned int count;
  unsigned int queue_size;
  unsigned int process_queue[MAX_QUEUE_SIZE]; // store task index here
} *s, key_pressed, key_released, flash_req;

// task 
#define STATE_INVALID    0 // no task
#define STATE_UNRUN      1 // ready, but never run
#define STATE_READY      2 // ready to run
#define STATE_BLOCKED    3 // has run, but now blocked by semaphore
#define STATE_DELAYED    4 // has run, but now awaiting timer

#define MAX_TASKS 10       // maximum number of valid tasks
int task_current = 0;      // index of last dispatched task
int task_count = 0;        // total number of valid tasks

int rtos_mode;             // mode
#define MODE_COOPERATIVE 0
#define MODE_PREEMPTIVE  1

struct _tcb
{
  unsigned int state;            // see STATE_ values above
  unsigned int pid;              // used to uniquely identify process
  unsigned int sp;               // location of stack pointer for process
  unsigned int priority;         // 0=lowest, 7=highest
  unsigned int current_priority;
  unsigned int ticks;            // ticks until sleep complete
} tcb[MAX_TASKS];

unsigned int stack[MAX_TASKS][256];

//-----------------------------------------------------------------------------
// RTOS Kernel                
//-----------------------------------------------------------------------------

void rtos_init(int mode)
{
  int i;
  rtos_mode = mode;
  // no tasks running
  task_count = 0;
  // clear out tcb records
  for (i = 0; i < MAX_TASKS; i++)
  {
    tcb[i].state = STATE_INVALID;
    tcb[i].pid = 0;
  }
  // REQUIRED: setup timer 3 for 1ms system timer
}

int rtos_scheduler()
{
  // REQUIRED: Implement prioritization to 8 levels
  static int ok;
  static int task = 0xFF;
  ok = FALSE;
  while (!ok)
  {
    task++;
    if (task >= MAX_TASKS)
      task = 0;
    ok = (tcb[task].state == STATE_READY) || (tcb[task].state == STATE_UNRUN);
  }
  return task;
}

int create_process(_fn fn, int priority)
{
  int ok = FALSE;
  int i = 0;
  int found = FALSE;
  IEC1bits.T3IE = 0; 
  // save starting address if room in task list
  if (task_count < MAX_TASKS)
  {
    // make sure fn not already in list (prevent reentrancy)
    while (!found && (i < MAX_TASKS))
    {
      found = (tcb[i++].pid == (unsigned int) fn);
    }
    if (!found)
    {
      // find first available tcb record
      i = 0;
      while (tcb[i].state != STATE_INVALID) {i++;}
      tcb[i].state = STATE_UNRUN;
      tcb[i].pid = (unsigned int) fn;
      tcb[i].sp = stack[i];
      tcb[i].priority = priority;    
      tcb[i].current_priority = priority;    
      // increment task count
      task_count++;
      ok = TRUE;
    }
  }
  IEC1bits.T3IE = 1;
  return ok;
}

// REQUIRED: modify this function to destroy a process
int destroy_process(_fn fn, int priority)
{
}

void rtos_start()
{
  int *SP = (int*)0x1E;
  // REQUIRED: modify to start the first unrun task as needed
  _fn fn;
  task_current = rtos_scheduler();
  *SP = tcb[task_current].sp;
  fn = (_fn)tcb[task_current].pid
  (*fn)();
}

// REQUIRED: Add code to manage blocked processes awaiting sleep() completion
void __attribute__((interrupt, no_auto_psv)) _T3Interrupt (void)
{
}

void init(void* p, int count)
{
  s = p;
  s->count = count;  
  s->queue_size = 0;
}

// REQUIRED: modify this function to yield execution back to scheduler
void yield()
{
	// push registers, call scheduler, pop registers, return to new function
	
}

// REQUIRED: modify this function to support 1ms system timer
// execution yielded back to scheduler until time elapses
void sleep(unsigned int tick)
{
	// push registers, set state to delayed, store timeout, call scheduler, pop registers, 
	// return to new function (separate unrun or ready processing)
}

// REQUIRED: modify this function to wait a semaphore with priority inheritance 
// return if avail (separate unrun or ready processing), else yield to scheduler
void wait(void* p)
{
}

// REQUIRED: modify this function to signal a semaphore is available
void signal(void* p)
{
}

//-----------------------------------------------------------------------------
// Subroutines                
//-----------------------------------------------------------------------------

// Initialize Hardware
void init_hw()
{
  AD1PCFGLbits.PCFG4 = 1;                    // make selected pins digital
  AD1PCFGLbits.PCFG5 = 1;
  LATBbits.LATB2 = 0;                        // write 0 into output latches
  LATBbits.LATB3 = 0;
  LATBbits.LATB4 = 0;
  LATBbits.LATB5 = 0;
  TRISBbits.TRISB2 = 0;                      // led pins outputs
  TRISBbits.TRISB3 = 0;
  TRISBbits.TRISB4 = 0;
  TRISBbits.TRISB5 = 0;
  CNPU1bits.CN11PUE = 1;                     // enable pull-ups for push buttons
  CNPU1bits.CN12PUE = 1;
  CNPU1bits.CN13PUE = 1;
  CNPU1bits.CN14PUE = 1;
}

int read_pbs()
{
  return (~PORTB >> 12);
}

// ------------------------------------------------------------------------------
//  Task functions
// ------------------------------------------------------------------------------

// one task must be ready at all times or the scheduler will fail
// the idle task is implemented for this purpose

void idle()
{
  while(TRUE) 
  { 
    PIN_ORANGE = 1;  
    __delay_ms(1);
    PIN_ORANGE = 0;
    yield();
  }
}

void flash_4hz()
{
  while(TRUE)
  {
    PIN_GREEN ^= 1;
    sleep(125);
  }
}

void one_shot()
{
  while(TRUE)
  {
    wait(&flash_req);
    PIN_YELLOW = 1;
    sleep(1000);
    PIN_YELLOW = 0;
  }
}

void part_of_lengthy_fn()
{
  // represent some lengthy operation
  __delay_ms(1);
  // give another process a chance
  yield();
}

void lengthy_fn()
{
  long i;
  while(TRUE)
  {
    for (i = 0; i < 4000; i++)
    {
      part_of_lengthy_fn();
    }
    PIN_RED ^= 1;
  }
}

void read_keys()
{
  int buttons;
  while(TRUE)
  {
    wait(&key_released);
    buttons = 0;
    while (buttons == 0)
    {
      buttons = read_pbs();
      yield();
    }
    signal(&key_pressed);
    if ((buttons & 1) != 0)
    {
      PIN_YELLOW ^= 1;
      PIN_RED = 1;
    }
    if ((buttons & 2) != 0)
    {
      signal(&flash_req);
      PIN_RED = 0;
    }
    if ((buttons & 4) != 0)
    {
      create_process(flash_4hz, 7);
    }
    if ((buttons & 8) != 0)
    {
      delete_process(flash_4hz);
	}

    yield();
  }
}

void debounce()
{
  int count;
  while(TRUE)
  {
    wait(&key_pressed);
    count = 10;
    while (count != 0)
    {  
      sleep(10);
      if (read_pbs() == 0)
        count--;
      else
        count = 10;
    }
    signal(&key_released);
  }
}

void uncooperative()
{
  while(TRUE)
  {
    while (read_pbs() == 8)
    {
    }
    yield();
  }
}

//-----------------------------------------------------------------------------
// Main                
//-----------------------------------------------------------------------------

int main(void)
{
  int ok;
  int pb;

  // initialize hardware
  init_hw();  

  // power-up flash
  PIN_RED = 1;
  __delay32(10000000);
  PIN_RED = 0;
  __delay32(10000000);

  // init semaphores
  init(&key_pressed, 0);
  init(&key_released, 1);
  init(&flash_req, 5);

  // initialize selected RTOS
  ok = FALSE;
  while (!ok)
  {
    pb = read_pbs();
    if (pb & 4) 
    {
      ok = TRUE;
      rtos_init(MODE_COOPERATIVE);
    }
    if (pb & 8) 
    {
      ok = TRUE;
      rtos_init(MODE_PREEMPTIVE);
    }
  }

  // add required idle process
  ok =  create_process(idle, 0) >= 0;

  // add other processes
  ok &= create_process(flash_4hz, 7) >= 0;
  ok &= create_process(lengthy_fn, 1) >= 0;
  ok &= create_process(one_shot, 4) >= 0;
  ok &= create_process(read_keys, 6) >= 0;
  ok &= create_process(debounce, 4) >= 0;
  ok &= create_process(uncooperative, 2) >= 0;

  // start up rtos
  if (ok) 
    rtos_start(); // never returns
  else
    PIN_RED = 1;

  return 0;
  // don't delete this unreachable code
  // if a function is only called once in your code, it will be
  // accessed with two goto instructions instead of call-return,
  // so any stack-based code will not function correctly
  yield(); sleep(0); wait(0); signal(0);
}
